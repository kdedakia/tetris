<!DOCTYPE html>

<html>
<head>
  <link rel="stylesheet" src="blockrain.css">
  <script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>
  <script src="blockrain.jquery.js"></script>
</head>

<body>
  <div class="game" style="width:300px; height:600px;"></div>
  <div class="stats">
    <h1>Generation: <span id="gen"></span> </h1>
    <h1>Edges: <span id="edges"></span> </h1>
    <h1>Holes: <span id="holes"></span> </h1>
    <h1>Blockades: <span id="blockades"></span> </h1>
    <h1>Walls: <span id="walls"></span> </h1>
    <h1>Score: <span id="score"></span> </h1>
  </div>
</body>

<style>
  .game {
    display: inline-block;
  }

  .stats {
    display: inline-block;
  }

  .blockrain-score-num {
    display: inline-block;
  }
</style>

<script type="text/javascript">
  Array.prototype.equals = function (array) {
      // if the other array is a falsy value, return
      if (!array)
          return false;

      // compare lengths - can save a lot of time
      if (this.length != array.length)
          return false;

      for (var i = 0, l=this.length; i < l; i++) {
          // Check if we have nested arrays
          if (this[i] instanceof Array && array[i] instanceof Array) {
              // recurse into the nested arrays
              if (!this[i].equals(array[i]))
                  return false;
          }
          else if (this[i] != array[i]) {
              // Warning - two different object instances will never be equal: {x:20} != {x:20}
              return false;
          }
      }
      return true;
  }

  Array.prototype.inArr = function (array) {
    for(var i=0;i<this.length;i++){
      if (this[i].equals(array) ) {
        return true;
      }
    }
    return false;
  }

  $(document).ready(function() {
    initialize();
    $('.game').blockrain({
      autoplay: true,
      autoplayRestart: true,
      theme: "candy",
      speed: 0
    });
    $("#score").append( $(".blockrain-score-num") );
    $(".blockrain-score").hide();
  });

  var min = -10;
  var max = 10;
  var retain = 0.4;
  var random_select = 0.05;
  var mutate = 0.05;

  var POP_IDX = 0;
  var ALL_DATA = [];
  var DATA = [];
  var FEATURES = ["holes","blockades","edges","walls","maxHeight"];
  var POP_LENGTH = 10;
  var NUM_GEN = 30;
  var F_H = [];
  var LOAD_DATA = true;


  function initialize() {
    if(pullAllData()) {
      evolveLast();
    }
    else {
      makeInitialPop();
    }
  }



  function inStorage(key) {
    if (Object.keys(localStorage).indexOf(key) != -1) {
      return true;
    }
    return false;
  }

  function pullAllData() {
    if (LOAD_DATA) {
      key = "ALL_DATA";
      if (inStorage(key)) {
        ALL_DATA = JSON.parse(localStorage[key]);
        F_H = JSON.parse(localStorage["F_H"]);
        return true;
      }
    }

    return false;
  }

  function saveData() {
    localStorage["ALL_DATA"] = JSON.stringify(ALL_DATA);
    localStorage["F_H"] = JSON.stringify(F_H);
  }

  function getSummary(i,j) {
      var obj = {"generation":i+1};
      var game = ALL_DATA[i][j];
      obj["score"] = game.score;
      for (var x=0;x<FEATURES.length;x++) {
        obj[FEATURES[x]] = game.weights[x];
      }

      return obj;
  }

  function maxScore() {
    var max = 0;

    for (var i=0; i < ALL_DATA.length; i++) {
      for (var j=0;j < ALL_DATA[i].length;j++) {
        var score = ALL_DATA[i][j].score
        if (score > max) {
          max = score;
        }
      }
    }
    return max;
  }

  // Get Top 10 Scores + Associated Weightings
  //TODO: fix duplicate score bug
  function topSummary(keep) {
    var top = {}; //top[score] = [i,j]
    var topScores = []; //Pop the lowest score, insert new top score

    for(var i=0;i<ALL_DATA.length;i++){
      for (var j=0;j<ALL_DATA[i].length;j++){
        var s = ALL_DATA[i][j].score

        if (topScores.length < keep){
          topScores.push(s);
          top[s] = [i,j];
        }
        //Replace lowest score
        else if (s > topScores[0]) {
          delete top[topScores.shift()]; //remove lowest
          topScores.push(s);
          topScores.sort(function(a, b){return a-b}); //ascending order
          top[s] = [i,j];
        }
      }
    }

    var topData = [];
    for (k in top) {
      topData.push(getSummary(top[k][0],top[k][1]));
    }

    return topData;
  }

  // Create first population randomly, if no data available
  function makeInitialPop() {
    var p = population(POP_LENGTH,FEATURES.length);
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }
  }

  // Evolve the last full set of data, used when reloading data
  function evolveLast() {
    var p = []
    for (var i=0;i<POP_LENGTH;i++) {
      p.push(ALL_DATA[ALL_DATA.length-1][i].weights)
    }
    DATA = ALL_DATA[ALL_DATA.length-1];

    $("#gen").html(F_H.length);
    p = evolve(p,retain,random_select,mutate);

    DATA = [];
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }
  }

  function finishEvolution() {
    p = []
    for (var i=0;i<POP_LENGTH;i++) {
      p.push(DATA[i].weights)
    }

    var pop_grade = parseInt(grade(p));
    F_H.push(pop_grade);
    $("#gen").html(F_H.length);
    p = evolve(p,retain,random_select,mutate);

    // Reset
    POP_IDX = 0;
    ALL_DATA.push(DATA);
    saveData();
    DATA = [];
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }

    return pop_grade;
  }


  /*
    GENETIC ALGORITHM CODE
  */

  function randint(min_val, max_val) {
    return Math.floor(Math.random() * (max_val - min_val + 1) + min_val);
  }
  function individual(num_features) {
    var features = [];

    for(var i = 0; i < num_features; i++) {
      features.push(Math.random() * (max - min) + min);
    }
    return features;
  }

  function population(count,length) {
    arr = [];
    for (var i =0; i < count; i++) {
      arr.push(individual(length));
    }
    return arr;
  }

  function fitness(id){
    return DATA[id].score;
  }

  function grade(pop) {
      var sum = 0;
      for (var i = 0; i < pop.length;i++) {
        sum += DATA[i].score
      }
      return sum/pop.length;
  }

  function evolve(pop,retain,random_select,mutate) {
      var graded = [];
      for (var x=0; x<pop.length;x++){
          graded.push([ fitness(x),pop[x] ]);
      }

      graded = graded.sort(function(a, b){return b[0]-a[0]});
      for (var i=0;i<graded.length;i++){
        graded[i] = graded[i][1];
      }

      var retain_length = Math.floor(graded.length * retain);
      var parents = [];
      for (var i=0;i < retain_length; i++) {
        parents.push(graded[i]);
      }

      // Randomly add other individuals to promote genetic diversity
      for (var i=retain_length; i<graded.length;i++) {
        if (random_select > Math.random() ){
            parents.push(graded[i]);
        }
      }

      // Mutate some individuals
      for (var i=0; i <parents_length;i++) {
        if ( mutate > Math.random() ) {
          pos_to_mutate = randint(0,individual.length-1);
          parents[i][pos_to_mutate] = randInt(min,max);
        }
      }

      // Crossover parents to create children
      var parents_length = parents.length;
      var desired_length = pop.length - parents_length;
      var children = [];
      while (children.length < desired_length) {
        male = randint(0,parents_length-1);
        female = randint(0, parents_length-1)
        if (male != female) {
          male = parents[male]
          female = parents[female]
          half = Math.ceil(male.length / 2);
          male = male.slice(0,half)
          female = female.slice(half);
          child = male.concat(female);
          children.push(child);
        }

      }
      parents = parents.concat(children);
      return parents;
  }


</script>

</html>
