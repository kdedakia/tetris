<!DOCTYPE html>

<html>
<head>
  <link rel="stylesheet" src="blockrain.css">
  <script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>
  <script src="blockrain.jquery.js"></script>
</head>

<body>
  <div class="game" style="width:300px; height:600px;"></div>
  <h1>Generation: <span id="gen"></span> </h1>
  <h1>Holes: <span id="holes"></span> </h1>
  <h1>Blockades: <span id="blockades"></span> </h1>
  <h1>Walls: <span id="walls"></span> </h1>
</body>

<script type="text/javascript">
  $(document).ready(function() {
    $('.game').blockrain({
      autoplay: true,
      autoplayRestart: true,
      theme: "candy",
      speed: 0
    });
  });

  var min = 0;
  var max = 10;

  var POP_IDX = 0;
  var ALL_DATA = [];
  var DATA = [];
  var FEATURES = ["holes","blockades","walls"];
  var POP_LENGTH = 10;
  var NUM_GEN = 30;
  var F_H = [];

  // Create first population randomly
  makePop();
  function makePop() {
    var p = population(POP_LENGTH,FEATURES.length);
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }
  }

  function finishEvolution() {
    var retain = 0.4;
    var random_select = 0.05;
    var mutate = 0.05;
    var pop_size = POP_LENGTH;

    p = []
    for (var i=0;i<POP_LENGTH;i++) {
      p.push(DATA[i].weights)
    }

    var pop_grade = parseInt(grade(p));
    F_H.push(pop_grade);
    $("#gen").html(F_H.length);
    p = evolve(p,retain,random_select,mutate);

    // Reset
    POP_IDX = 0;
    ALL_DATA.push(DATA);
    DATA = [];
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }

    return pop_grade;
  }

  function randint(min_val, max_val) {
    return Math.floor(Math.random() * (max_val - min_val + 1) + min_val);
  }
  function individual(num_features) {
    var features = [];

    for(var i = 0; i < num_features; i++) {
      features.push(Math.random() * (max - min) + min);
    }
    return features;
  }

  function population(count,length) {
    arr = [];
    for (var i =0; i < count; i++) {
      arr.push(individual(length));
    }
    return arr;
  }

  function fitness(id){
    return DATA[id].score;
  }

  function grade(pop) {
      var sum = 0;
      for (var i = 0; i < pop.length;i++) {
        sum += DATA[i].score
      }
      return sum/pop.length;
  }

  function evolve(pop,retain,random_select,mutate) {
      var graded = [];
      for (var x=0; x<pop.length;x++){
          graded.push([ fitness(x),pop[x] ]);
      }

      graded = graded.sort(function(a, b){return b[0]-a[0]});
      for (var i=0;i<graded.length;i++){
        graded[i] = graded[i][1];
      }

      var retain_length = Math.floor(graded.length * retain);
      var parents = [];
      for (var i=0;i < retain_length; i++) {
        parents.push(graded[i]);
      }

      // Randomly add other individuals to promote genetic diversity
      for (var i=retain_length; i<graded.length;i++) {
        if (random_select > Math.random() ){
            parents.push(graded[i]);
        }
      }

      // Mutate some individuals
      for (var i=0; i <parents_length;i++) {
        if ( mutate > Math.random() ) {
          pos_to_mutate = randint(0,individual.length-1);
          parents[i][pos_to_mutate] = randInt(min,max);
        }
      }

      // Crossover parents to create children
      var parents_length = parents.length;
      var desired_length = pop.length - parents_length;
      var children = [];
      while (children.length < desired_length) {
        male = randint(0,parents_length-1);
        female = randint(0, parents_length-1)
        if (male != female) {
          male = parents[male]
          female = parents[female]
          half = Math.ceil(male.length / 2);
          male = male.slice(0,half)
          female = female.slice(half);
          child = male.concat(female);
          children.push(child);
        }

      }
      parents = parents.concat(children);
      return parents;
  }


</script>

<style>

</style>

</html>
