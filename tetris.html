<!DOCTYPE html>

<html>
<head>
  <link rel="stylesheet" src="blockrain.css">
  <script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>
  <script src="blockrain.jquery.js"></script>
</head>

<body>
  <div class="game" style="width:300px; height:600px;"></div>
  <div class="stats">
    <label for="population_length">Population Length</label>
    <input id="population_length" type="text" placeholder="Population Length"/>
    <label for="elite_length">Number of Elite</label>
    <input id="elite_length" type="text" placeholder="Number of Elite"/>
    <label for="mutate">Mutation Rate</label>
    <input id="mutate" type="text" placeholder="Mutation Rate"/>
    <label for="retain">Retain Rate</label>
    <input id="retain" type="text" placeholder="Retain Rate"/>
    <label for="random_rate">Random Select Rate</label>
    <input id="random_rate" type="text" placeholder="Random Select Rate"/>
    <label for="min">Min</label>
    <input id="min" type="text" placeholder="Min"/>
    <label for="max">Max</label>
    <input id="max" type="text" placeholder="Max"/>
    <input id="change_btn" type="button" value="Change Parameters" />
    <br/>
    <input id="scrap_btn" type="button" value="Scrap Run" />
    <br/>
    <input id="save_btn" type="button" value="Save Run" />


    <h1>Generation: <span id="gen"></span>  (<span id="progress"></span>%)</h1>
    <h1>Edges: <span id="edges"></span> </h1>
    <h1>Holes: <span id="holes"></span> </h1>
    <h1>Blockades: <span id="blockades"></span> </h1>
    <h1>Walls: <span id="walls"></span> </h1>
    <h1>Score: <span id="score"></span> </h1>
  </div>
</body>

<style>
  .game {
    display: inline-block;
  }

  .stats {
    display: inline-block;
  }

  .stats input {
    display: block;
  }

  .blockrain-score-num {
    display: inline-block;
  }
</style>

<script type="text/javascript">
  Array.prototype.equals = function (array) {
      // if the other array is a falsy value, return
      if (!array)
          return false;

      // compare lengths - can save a lot of time
      if (this.length != array.length)
          return false;

      for (var i = 0, l=this.length; i < l; i++) {
          // Check if we have nested arrays
          if (this[i] instanceof Array && array[i] instanceof Array) {
              // recurse into the nested arrays
              if (!this[i].equals(array[i]))
                  return false;
          }
          else if (this[i] != array[i]) {
              // Warning - two different object instances will never be equal: {x:20} != {x:20}
              return false;
          }
      }
      return true;
  }

  Array.prototype.inArr = function (array) {
    for(var i=0;i<this.length;i++){
      if (this[i].equals(array) ) {
        return true;
      }
    }
    return false;
  }

  $(document).ready(function() {
    initialize();
    $('.game').blockrain({
      autoplay: true,
      autoplayRestart: true,
      theme: "candy",
      speed: 0
    });
    $("#score").append( $(".blockrain-score-num") );
    $(".blockrain-score").hide();
  });

  /* GENETIC ALGORITHM PARAMETERS */
  var min = 0;
  var max = 10;
  var retain = 0.4;
  var random_rate = 0.05;
  var mutate = 0.03;
  var elite_length = 2;

  /* GLOBAL VARIABLES */
  var POP_IDX = 0;
  var ALL_DATA = [];
  var DATA = [];
  var FEATURES = ["holes","blockades","edges","walls","maxHeight"];
  var POP_LENGTH = 8;
  var NUM_GEN = 30;
  var F_H = [];
  var LOAD_DATA = true;

  function restartGame() {
    resetData();
    changeParams();
    initialize();
    $(".game").blockrain('restart');
  }

  function saveRun() {
    var ALL_RUNS = [];
    if(inStorage("ALL_RUNS")) {
      ALL_RUNS = JSON.parse(localStorage["ALL_RUNS"]);
    }

    var run = {};
    run["pop_length"] = POP_LENGTH;
    run["features"] = FEATURES;
    run["min"] = min;
    run["max"] = max;
    run["retain"] = retain;
    run["random_rate"] = random_rate;
    run["mutate"] = mutate;
    run["elite_length"] = elite_length;
    run["data"] = ALL_DATA;
    run["fh"] = F_H;
    ALL_RUNS.push(run);
    localStorage["ALL_RUNS"] = JSON.stringify(ALL_RUNS);

    restartGame();
  }

  function resetData() {
    var to_reset = ["DATA","ALL_DATA","F_H"];
    for (var i=0;i<to_reset.length;i++) {
      delete localStorage[to_reset[i]];
    }
    DATA = [];
    ALL_DATA = [];
    F_H = [];
    POP_IDX = 0;
    numGame();
  }

  function numGame() {
    var num = 0.0;
    if(DATA.length != 0) {
      for(var i=0;i<POP_LENGTH;i++) {
        num++;
        if (DATA[i].score == undefined) {
          num = (num/POP_LENGTH*100).toFixed(2);
          break;
        }
      }
    }

    $("#progress").html(num);
    return;
  }

  function changeParams() {
    POP_LENGTH = parseInt($("#population_length").val());
    elite_length = parseInt($("#elite_length").val());
    mutate = parseFloat($("#mutate").val());
    retain = parseFloat($("#retain").val());
    random_rate = parseFloat($("#random_rate").val());
    min = parseFloat($("#min").val());
    max = parseFloat($("#max").val());
  }

  function initialize() {
    if(pullAllData()) {
      evolveLast();
    }
    else {
      resetData();
      makeInitialPop();
    }

    $("#population_length").val(POP_LENGTH);
    $("#elite_length").val(elite_length);
    $("#mutate").val(mutate);
    $("#retain").val(retain);
    $("#random_rate").val(random_rate);
    $("#min").val(min);
    $("#max").val(max);
  }

  $("#save_btn").click(function() {
    saveRun();
  });

  $("#scrap_btn").click(function() {
    restartGame();
  });

  $("#change_btn").click(function() {
    restartGame();
  });


  function inStorage(key) {
    if (Object.keys(localStorage).indexOf(key) != -1) {
      return true;
    }
    return false;
  }

  function pullAllData() {
    if (LOAD_DATA) {
      key = "ALL_DATA";
      if (inStorage(key)) {
        ALL_DATA = JSON.parse(localStorage[key]);
        F_H = JSON.parse(localStorage["F_H"]);
        return true;
      }
    }

    return false;
  }

  function saveData() {
    localStorage["ALL_DATA"] = JSON.stringify(ALL_DATA);
    localStorage["F_H"] = JSON.stringify(F_H);
  }

  function getSummary(i,j) {
      var obj = {"generation":i+1};
      var game = ALL_DATA[i][j];
      obj["score"] = game.score;
      for (var x=0;x<FEATURES.length;x++) {
        obj[FEATURES[x]] = game.weights[x];
      }

      return obj;
  }

  function maxScore() {
    var max = 0;

    for (var i=0; i < ALL_DATA.length; i++) {
      for (var j=0;j < ALL_DATA[i].length;j++) {
        var score = ALL_DATA[i][j].score
        if (score > max) {
          max = score;
        }
      }
    }
    return max;
  }

  // Get Top 10 Scores + Associated Weightings
  //TODO: fix duplicate score bug
  function topSummary(keep) {
    var top = {}; //top[score] = [i,j]
    var topScores = []; //Pop the lowest score, insert new top score

    for(var i=0;i<ALL_DATA.length;i++){
      for (var j=0;j<ALL_DATA[i].length;j++){
        var s = ALL_DATA[i][j].score

        if (topScores.length < keep){
          topScores.push(s);
          top[s] = [i,j];
        }
        //Replace lowest score
        else if (s > topScores[0]) {
          delete top[topScores.shift()]; //remove lowest
          topScores.push(s);
          topScores.sort(function(a, b){return a-b}); //ascending order
          top[s] = [i,j];
        }
      }
    }

    var topData = [];
    for (k in top) {
      topData.push(getSummary(top[k][0],top[k][1]));
    }

    return topData;
  }

  // Create first population randomly, if no data available
  function makeInitialPop() {
    $("#gen").html(F_H.length);
    var p = population(POP_LENGTH,FEATURES.length);
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }
  }

  // Evolve the last full set of data, used when reloading data
  function evolveLast() {
    var p = []
    for (var i=0;i<POP_LENGTH;i++) {
      p.push(ALL_DATA[ALL_DATA.length-1][i].weights)
    }
    DATA = ALL_DATA[ALL_DATA.length-1];

    $("#gen").html(F_H.length);
    p = evolve(p,retain,random_rate,mutate);

    DATA = [];
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }
  }

  function finishEvolution() {
    p = []
    for (var i=0;i<POP_LENGTH;i++) {
      p.push(DATA[i].weights)
    }

    var pop_grade = parseInt(grade(p));
    F_H.push(pop_grade);
    $("#gen").html(F_H.length);
    p = evolve(p,retain,random_rate,mutate);

    // Reset
    POP_IDX = 0;
    ALL_DATA.push(DATA);
    saveData();
    DATA = [];
    for(var i=0;i<POP_LENGTH;i++){
      DATA.push({"id":i,"weights":p[i]});
    }

    return pop_grade;
  }


  /*
    GENETIC ALGORITHM CODE
  */

  function randint(min_val, max_val) {
    return Math.floor(Math.random() * (max_val - min_val + 1) + min_val);
  }
  function individual(num_features) {
    var features = [];

    for(var i = 0; i < num_features; i++) {
      features.push(Math.random() * (max - min) + min);
    }
    return features;
  }

  function population(count,length) {
    arr = [];
    for (var i =0; i < count; i++) {
      arr.push(individual(length));
    }
    return arr;
  }

  function fitness(id){
    return DATA[id].score;
  }

  function grade(pop) {
      var sum = 0;
      for (var i = 0; i < pop.length;i++) {
        sum += DATA[i].score
      }
      return sum/pop.length;
  }

  function evolve(pop,retain,random_rate,mutate) {
      var graded = [];
      for (var x=0; x<pop.length;x++){
          graded.push([ fitness(x),pop[x] ]);
      }

      graded = graded.sort(function(a, b){return b[0]-a[0]});
      for (var i=0;i<graded.length;i++){
        graded[i] = graded[i][1];
      }

      var retain_length = Math.floor(graded.length * retain);
      var parents = [];

      /*
      pop = 15
      retain = 0.4
      r_l = 6
      e_l = 2
      so take 0,1 as elites 0->e_l-1
      mutate 2,3,4,5 e_l -> total: r_l - e_l
      */
      for (var i=elite_length;i < retain_length; i++) {
        parents.push(graded[i]);
      }

      // Randomly add other individuals to promote genetic diversity
      for (var i=retain_length; i<graded.length;i++) {
        if (random_rate > Math.random() ){
            parents.push(graded[i]);
        }
      }

      // Mutate some individuals
      for (var i=0; i <parents_length;i++) {
        if ( mutate > Math.random() ) {
          pos_to_mutate = randint(0,individual.length-1);
          parents[i][pos_to_mutate] = randInt(min,max);
        }
      }

      // Add elites
      for (var i=0;i <elite_length;i++) {
        parents.push(graded[i]);
      }

      // Crossover parents to create children
      var parents_length = parents.length;
      var desired_length = pop.length - parents_length;
      var children = [];
      while (children.length < desired_length) {
        male = randint(0,parents_length-1);
        female = randint(0, parents_length-1)
        if (male != female) {
          male = parents[male]
          female = parents[female]
          half = Math.ceil(male.length / 2);
          male = male.slice(0,half)
          female = female.slice(half);
          child = male.concat(female);
          children.push(child);
        }

      }
      parents = parents.concat(children);
      return parents;
  }


</script>

</html>
